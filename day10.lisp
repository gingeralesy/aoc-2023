(in-package #:aoc-2023)

;; https://adventofcode.com/2023/day/10

(defun d10-data ()
  (flet ((connections-from (x y map width height)
           (let ((north (1- y))
                 (south (1+ y))
                 (west (1- x))
                 (east (1+ x))
                 (connections ()))
             (when (and (< 0 west) (find :east (aref map y west)))
               (push :west connections))
             (when (and (< east width) (find :west (aref map y east)))
               (push :east connections))
             (when (and (< 0 north) (find :south (aref map north x)))
               (push :north connections))
             (when (and (< south height) (find :north (aref map south x)))
               (push :south connections))
             connections)))
    (let ((map (make-queue))
          (width 0)
          (height 0)
          (start-x -1)
          (start-y -1))
      (do-file (line "day10.txt")
        (unless (< 0 width) (setf width (length line)))
        (queue-push
         (loop for x from 0 below width
               collect (ecase (char line x)
                         (#\| '(:north :south))
                         (#\- '(:east :west))
                         (#\L '(:north :east))
                         (#\J '(:north :west))
                         (#\7 '(:south :west))
                         (#\F '(:south :east))
                         (#\. '())
                         (#\S
                          (unless (or (< start-x 0) (< start-y 0))
                            (error "Multiple start points."))
                          (setf start-x x)
                          (setf start-y height)
                          '())))
         map)
        (incf height))
      (when (or (< start-x 0) (< start-y 0)) (error "Start point not found."))
      (let* ((map (make-array (list height width)
                              :element-type 'list
                              :initial-contents (queue-as-list map)))
             (start (connections-from start-x start-y map width height)))
        (unless (= 2 (length start))
          (error "Invalid start at (~a, ~a): ~a" start-x start-y start))
        (setf (aref map start-y start-x) start)
        (values map start-x start-y width height)))))

(defun d10-directions (map from-x from-y)
  (loop for direction in (aref map from-y from-x)
        for x = (ecase direction
                  (:west (1- from-x))
                  (:east (1+ from-x))
                  ((:north :south) from-x))
        for y = (ecase direction
                  (:north (1- from-y))
                  (:south (1+ from-y))
                  ((:west :east) from-y))
        collect `(,x ,y)))

(defun d10p1 ()
  (multiple-value-bind (map start-x start-y width height) (d10-data)
    (let ((distances (make-array `(,height ,width) :element-type '(unsigned-byte 32)
                                                   :initial-element #xffffffff))
          (final-distance 0))
      (labels ((traverse (from-x from-y)
                 (let ((travel (1+ (aref distances from-y from-x))))
                   (loop for (to-x to-y) in (d10-directions map from-x from-y)
                         do (unless (< (aref distances to-y to-x) travel)
                              (setf (aref distances to-y to-x) travel)
                              (setf final-distance travel)
                              (traverse to-x to-y))))))
        (setf (aref distances start-y start-x) 0)
        (traverse start-x start-y)
        final-distance))))

;; Answer: 6599

(defun d10-pipe-map (map start-x start-y width height)
  (declare (optimize (speed 3)))
  (let ((pipe (make-array `(,height ,width) :element-type 'boolean :initial-element NIL)))
    (labels ((traverse (from-x from-y)
               (loop for (to-x to-y) in (d10-directions map from-x from-y)
                     do (unless (aref pipe to-y to-x)
                          (setf (aref pipe to-y to-x) T)
                          (traverse to-x to-y)))))
      (setf (aref pipe start-y start-x) T)
      (traverse start-x start-y)
      pipe)))

(defun d10p2 ()
  (multiple-value-bind (pipes start-x start-y width height) (d10-data)
    (declare (ignore start-x start-y))
    (let ((map (make-array `(,(1+ height) ,(1+ width)) :element-type '(unsigned-byte 4)
                                                       :initial-element 0))
          ;; (pipe-map (d10-pipe-map pipes start-x start-y width height))
          (visited (make-array `(,(1+ height) ,(1+ width)) :element-type 'boolean
                                                           :initial-element NIL))
          (node->dir (loop with table = (make-hash-table)
                           for node from 0 below 16
                           for dirs = ()
                           when (zerop (logand 8 node)) do (push :east dirs)
                           when (zerop (logand 4 node)) do (push :west dirs)
                           when (zerop (logand 2 node)) do (push :south dirs)
                           when (zerop (logand 1 node)) do (push :north dirs)
                           do (setf (gethash node table) dirs)
                           finally (return table))))
      (labels ((traverse (from-x from-y)
                 (setf (aref visited from-y from-x) T)
                 (let ((node 0)
                       (north-edge-p (<= from-y 0))
                       (south-edge-p (<= height from-y))
                       (west-edge-p (<= from-x 0))
                       (east-edge-p (<= width from-x)))
                   (declare (type (unsigned-byte 4) node))
                   (when (or north-edge-p
                             (and (not west-edge-p) (not east-edge-p)
                                  (find :east (aref pipes (1- from-y) (1- from-x)))
                                  (find :west (aref pipes (1- from-y) from-x))))
                     (setf node (logior node 1))) ;; North closed.
                   (when (or south-edge-p
                             (and (not west-edge-p) (not east-edge-p)
                                  (find :east (aref pipes from-y (1- from-x)))
                                  (find :west (aref pipes from-y from-x))))
                     (setf node (logior node 2))) ;; South closed.
                   (when (or west-edge-p
                             (and (not north-edge-p) (not south-edge-p)
                                  (find :south (aref pipes (1- from-y) (1- from-x)))
                                  (find :north (aref pipes from-y (1- from-x)))))
                     (setf node (logior node 4))) ;; West closed.
                   (when (or east-edge-p
                             (and (not north-edge-p) (not south-edge-p)
                                  (find :south (aref pipes (1- from-y) from-x))
                                  (find :north (aref pipes from-y from-x))))
                     (setf node (logior node 8))) ;; East closed.
                   (setf (aref map from-y from-x) node)
                   (loop for dir in (gethash node node->dir)
                         for x = (ecase dir
                                   (:west (1- from-x))
                                   (:east (1+ from-x))
                                   ((:north :south) from-x))
                         for y = (ecase dir
                                   (:north (1- from-y))
                                   (:south (1+ from-y))
                                   ((:west :east) from-y))
                         when (and (<= 0 x) (<= 0 y) (< x (1+ width)) (< y (1+ height))
                                   (not (aref visited y x)))
                         do (traverse x y)))))
        (traverse 0 0)
        (let ((count 0))
          ;; (dotimes (y (1+ height))
          ;;   (format T "~&")
          ;;   (dotimes (x (1+ width))
          ;;     (format T "~c" (if (aref visited y x) #\# #\.)))
          ;;   (format T "~%"))
          (dotimes (y (1- height) count)
            (dotimes (x (1- width))
              (unless (or (aref visited y x) (aref visited y (1+ x))
                          (aref visited (1+ y) x) (aref visited (1+ y) (1+ x)))
                (incf count)))))))))

;; Answer: 477
