(in-package #:aoc-2023)

;; https://adventofcode.com/2023/day/1

(declaim (inline d1-char->number))
(defun d1-char->number (ch)
  (declare (optimize (speed 3)))
  (ecase ch
    (#\1 1)
    (#\2 2)
    (#\3 3)
    (#\4 4)
    (#\5 5)
    (#\6 6)
    (#\7 7)
    (#\8 8)
    (#\9 9)))

(declaim (inline d1-string->number))
(defun d1-string->number (str)
  (declare (type (simple-array character (*)) str))
  (declare (optimize (speed 3)))
  (alexandria:eswitch (str :test #'string=)
    ("one" 1)
    ("two" 2)
    ("three" 3)
    ("four" 4)
    ("five" 5)
    ("six" 6)
    ("seven" 7)
    ("eight" 8)
    ("nine" 9)))

(defun d1p1 ()
  (declare (optimize (speed 3)))
  (let ((sum 0))
    (declare (type (unsigned-byte 32) sum))
    (do-file (line "day1.txt" sum)
      (let ((length (length line))
            first-digit last-digit)
        (dotimes (i (length line))
          (let ((ch-a (char line i))
                (ch-b (char line (- length i 1))))
            (when (and (null first-digit) (digit-char-p ch-a))
              (setf first-digit (d1-char->number ch-a)))
            (when (and (null last-digit) (digit-char-p ch-b))
              (setf last-digit (d1-char->number ch-b)))
            (when (and first-digit last-digit) (return))))
        (setf sum (+ sum (* 10 first-digit) last-digit))))))

;; Answer: 54597

(defun d1-starts-with-p (line pattern from)
  (declare (type (simple-array character (*)) line pattern))
  (declare (type (unsigned-byte 32) from))
  (declare (optimize (speed 3)))
  (let ((line-len (length line))
        (pattern-len (length pattern)))
    (dotimes (i pattern-len T)
      (let ((j (+ from i)))
        (unless (and (< i pattern-len) (< j line-len) (char= (char pattern i) (char line j)))
          (return NIL))))))

(defun d1-ends-with-p (line pattern from)
  (declare (type (simple-array character (*)) line pattern))
  (declare (type (unsigned-byte 32) from))
  (declare (optimize (speed 3)))
  (let ((pattern-len (length pattern)))
    (dotimes (i pattern-len T)
      (let ((j (- from i 1))
            (i (- pattern-len i 1)))
        (unless (and (<= 0 i) (<= 0 j) (char= (char pattern i) (char line j)))
          (return NIL))))))

(defun d1-parse-line (line)
  (declare (type (simple-array character (*)) line))
  (declare (optimize (speed 3)))
  (let ((line-len (length line))
        (patterns #("one" "two" "three" "four" "five" "six" "seven" "eight" "nine"))
        start-match end-match)
    (dotimes (i line-len (error "Invalid line: ~a" line))
      (let ((start-ch (char line i))
            (end-ch (char line (- line-len i 1))))
        (when (and (null start-match) (digit-char-p start-ch))
          (setf start-match (d1-char->number start-ch)))
        (when (and (null end-match) (digit-char-p end-ch))
          (setf end-match (d1-char->number end-ch))))
      (when (and start-match end-match) (return (values start-match end-match)))
      (dotimes (j 9)
        (let ((pattern (svref patterns j)))
          (when (and (null start-match) (d1-starts-with-p line pattern i))
            (setf start-match (d1-string->number pattern)))
          (when (and (null end-match) (d1-ends-with-p line pattern (- line-len i)))
            (setf end-match (d1-string->number pattern)))
          (when (and start-match end-match) (return))))
      (when (and start-match end-match) (return (values start-match end-match))))))

(defun d1p2 ()
  (declare (optimize (speed 3)))
  (let ((sum 0))
    (declare (type (unsigned-byte 32) sum))
    (do-file (line "day1.txt" sum)
      (multiple-value-bind (start-value end-value)
          (d1-parse-line line)
        (declare (type (integer 1 9) start-value end-value))
        (setf sum (+ sum (* 10 start-value) end-value))))))

;; Answer: 54504
